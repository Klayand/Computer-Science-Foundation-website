<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8">
		<title>教学界面</title>
		<link rel="stylesheet" href="../automove.css" />
		<link rel="stylesheet" href="../../CSS/sidebar.css" />
		<link rel="stylesheet" href="../../CSS/font-awesome.min.css" />
		<script src="../jquery.mini.js" type="text/javascript" charset="utf-8"></script>
    <style>
		img{
			vertical-align: middle;
		}
	</style>
	</head>
	<body>
		<!-- 这里是侧边栏开始 -->
        
		

	
		<!-- 这里是侧边栏结束 -->
		<!-- 这里是头部导航栏 -->
		<div class="header">
			<div class="back">
				<a href="../Algorithm.html">
					 返回 </a>
			</div>

			<div class="ex_reading1">
				<div class="pic1">
					<img src="../image/拓展阅读图标（50）.png">
				</div>
				<div class="to_exread">
					<a href="https://www.jianshu.com/p/bc588cedbcbe">拓展阅读</a>
				</div>
			</div>
			
			<div class="biaoti">
				数据结构的繁衍
			</div>
		</div>
		<!-- 头部之下的内容 -->
		<!-- 这里是progress开始 -->
		<div class="progress">
			<div class="catalog">
				<p>目录</p>
				<a href="#nlp">
					<p>&emsp;1.数据结构与算法的关系</p>
				</a>
				<a href="#flow">
					<p>&emsp;2.数据结构与算法分类</p>
				</a>
				<a href="#next">
					<p>&emsp;3.列举几个算法结构</p>
				</a>
			</div>
		</div>
		<!-- 这里是progress结束 -->
		<!-- 下面是教学内容开始 -->
		<div class="content">
			<div class="cons1">
				<div class="show">
					<div class="teacher">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>请按回车显示内容</p>
					</div>
				</div>
			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word1">
						<a name="nlp">
							<p>数据结构与算法的关系<br></p>
						</a>
					</div>
				</div>
			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher1">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>数据结构主要讲解数据的组织形式，换句话说，我就是我们要怎样把这些数据存储起来，所以有列表、堆、栈、树、图，这是数据结构的重点。</p>
					</div>
				</div>

			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p><p>而算法，则注重的是思想，比如列表里的元素怎么排序、怎么在当前的存储结构中找到最大的数和最小的数？等等，说白了就是解决现实中问题的思想。所以才会有分治思想、贪心思想、动态规划这些经典算法。</p></p>
					</div>
				</div>
			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher1">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>算法要高效实现，需要数据结构来配合。</p>
					</div>
				</div>

			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher2">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p><P style="color: red;">算法的五个特性：输入、输出、有穷、确定和可行性</P></p>
						<p>这个移动起来的过程是这样的:</p>
						<p>从输入输出角度考虑，算法要对数据进行处理，不可避免的要用到对数据进行组织。需要处理的信息越复杂，处理过程越复杂，那么良好的数据组织就越重要，也就体现在数据结构的选取上了。</p>
						<img src="../image/图片2.png" style="margin-left: 200px;">
						
					</div>
				</div>
			</div>
			
			<div class="cons">
				<div class="show">
					<div class="teacher">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word1">
						<a name="flow">
							<p>数据结构与算法分类</p>
						</a>
					</div>
				</div>

			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher4">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>那么现在，让我们简要了解下算法分类吧！</p>
						<img src="../image/十个算法.png" style="margin-left: 300px;">
						
						
					</div>
					
				</div>

			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher3">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>接着，让我们了解下数据结构分类。</p>
						<img src="../image/十个数据结构.png" style="margin-left: 300px;">
					</div>
				</div>
			</div>
			
			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word1">
						<a name="next">
							<p>列举几个算法结构</p>
						</a>
					</div>
				</div>

			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>一．枚举（简单粗暴）</p>
						<p>最为简单的思想，枚举算法。枚举也叫穷举，顾名思义，就是穷尽列举。枚举思想的应用场景十分广泛，也非常容易理解。简单来说，枚举就是将问题的可能解依次列举出来，然后一一带入问题检验，从而从一系列可能解中获得能够解决问题的精确解。枚举思想是最接近人的思维方式，在更多的时候是用来帮助我们去「理解问题」，而不是「解决问题」。</p>
						<img src="../image/图片3.png" style="margin-left: 300px;">
					</div>
				</div>
			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher1">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>二．递推算法</p>
						<p>递推思想跟枚举思想一样，都是接近人类思维方式的思想，甚至在实际生活具有比枚举思想更多的应用场景。人脑在遇到未知的问题时，大多数人第一直觉都会从积累的「先验知识」出发，试图从「已知」推导「未知」，从而解决问题，说服自己。计算机在运用递推思想时，大多都是重复性的推理。比方说，从「今天是1号」推出「明天是2号」。这种推理的结构十分类似，往往可以通过继而往复的推理就可以得到最终的解。</p>
						<img src="../image/图片4.png "style="margin-left: 300px;">
					</div>
				</div>
			</div>
			<div class="cons">
				<div class="show">
					<div class="teacher2">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>三.递归算法</p>
						<br>
						<P>递归算法实际上是把问题转化成规模更小的同类子问题，先解决子问题，再通过相同的求解过程逐步解决更高层次的问题，最终获得最终的解。</P>
						<br>
						<p>用一句话来形容递归算法的实现，就是在函数或者子过程的内部，直接或间接的调用自己算法。所以在实现的过程中，最重要的是确定递归过程终止的条件，也就是迭代过程跳出的条件判断。否则，程序会在自我调用中无限循环，最终导致内存溢出而崩溃。</p>
						<br>
						<p>递归算法的图解可如下图。很明显，递归思想其实就是一个套娃过程。一般官方都是严禁套娃行为的。所以在使用时一定要明确「套娃」举动的停止条件，及时止损。</p>
						<img src="../image/图片5.png" style="margin-left: 200px;">
					</div>
				</div>
			</div>

			<div class="cons">
				<div class="show">
					<div class="teacher2">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>四.分治</p>
							<br>
							<P>分治，分而治之。</P>
							<br>
							<P>分治算法的核心步骤就是两步，一是分，二是治。但这还引申出了一系列的问题，为什么分，怎么分，怎么治，治后如何。</P>
							<br>
							<P>分治算法很像是一种向下管理的思想，从最高级层层划分，将子任务划分给不同的子模块，进而可以进行大问题的拆分，对系统问题的粒度进行细化，寻求最底层的最基本的解。</P>
						    <br>
							<P>分治思想的图解可见下图。通过层层粒度上的划分，将原问题划分为最小的子问题，然后再向上依次得到更高粒度的解。从上而下，再从下而上。先分解，再求解，再合并。</P>
							<img src="../image/图片6.png" style="margin-left: 200px;">
						</div>
				</div>
			</div>

			<div class="cons">
				<div class="show">
					<div class="teacher2">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>五.动态规划<br><br><br>
						</p>
					</div>
				</div>
			</div>

			<div class="cons">
				<div class="show">
					<div class="teacher2">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>动态规划同样需要将问题划分为多个子问题，但是子问题之间往往不是互相独立的。当前子问题的解可看作是前多个阶段问题的完整总结。因此这就需要在在子问题求解的过程中进行多阶段的决策，同时当前阶段之前的决策都能够构成一种最优的子结构。这就是所谓的最优化原理。</p>
							<br>
							<p>动归的开始需要将问题按照一定顺序划分为各个阶段，然后确定每个阶段的状态，如图中节点的F0等。然后重点是根据决策的方法来确定状态转移方程。也就是需要根据当前阶段的状态确定下一阶段的状态。</p>
							<br>
							<img src="../image/图片7.png" style="margin-left: 200px;">
					</div>
				</div>
			</div>


			<div class="cons">
				<div class="show">
					<div class="teacher2">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>六.贪心</p>
							<br>
							<p>贪心算法，我愿称之为最现实的算法思想。</p>
							<br>
							<p>贪心算法的实现过程就是从问题的一个初始解出发，每一次都作出「当前最优」的选择，直至遇到局部极值点。贪心所带来的局限性很明显，就是无法保证最后的解是最优的，很容易陷入局部最优的情况。</p>
							<br>
							<p>但是它每一次做选择的速度很快，同时判断条件简单，能够比较快速的给出一种差不多的解决方案。</p>
							<br>
							<p>这个图表示的是求解对多条直线的交点。很显然，下图中的直线是不存在统一交点的，但是可以通过算法求得统一交点的最优解。若是采用贪心算法，那么在进行迭代时，每一次都会选择离此时位置最近的直线进行更新。这样一来，在经过多次迭代治后，交点的位置就会在某一片区域无限轮回跳转。而这片区域也就是能求得出的大致的最优解区域。</p>
							<img src="../image/图片8.png" style="margin-left: 200px;">
					</div>
				</div>
			</div>
			

			<div class="cons">
				<div class="show">
					<div class="teacher2">
						<img src="../image/老师头像（36）.png" class="teacher_pic">
					</div>
					<div class="word">
						<p>七.回溯</p>
							<br>
							<p>回溯算法也可称作试探算法，简单来说，回溯的过程就是在做出下一步选择之前，先对每一种可能进行试探；只有当可能性存在时才会向前迈进，倘若所有选择都不可能，那么则向后退回原来的位置，重新选择。</p>
							<br>
							<P>假设目的是从最O0到达O4，需要对所有节点进行回溯遍历路径。那么回溯算法的过程则需要在前进的每一步对所有可能的路径进行试探。</P>
                            <br>
							<P>比方说，O0节点前进的路径有三条，分别是上中下条的O1。回溯过程的开始，先走上面的O1，然后能够到达上面 O2，但是这时是一条死路。那么就需要从O2退回到O1，而此时O1的唯一选择也走不通，所以还需要从O1退回到O0。然后继续试探中间的O1。</P>
							<br>
							<P>回溯算法的过程就是不断进行这样的试探、判断、退回并重新试探，直至找到一条完整的前进路径。只不过在这个过程中，可以通过「剪枝」等限制条件降低试探搜索的空间，从而避免重复无效的试探。比方说上下的O2节点，在经过O0-O1-O2的试探之后，就已经验证了该节点不可行性，下次就无须从O1开始重复对O2的试探。							</P>
						
					</div>
				</div>
			</div>
			
			
			<div class="enter">
				<div class="shadow">
				</div>
				<div class="pic_enter">
					<img src="../image/回车图标3.png">
				</div>
			</div>
			<!-- 这里是回车区域结束 -->
			<!-- 这里是JS区域开始 -->
			<script type="text/javascript">
				var enter = document.querySelector('.enter');
				var cons = $(".cons");
				var content = $(".content");
				i = 0;
				document.onkeydown = function() {
					// 这个是控制现实和隐藏
					cons[i].style.display = 'block';
					// 这个是控制自动移位
					if (i >= 2) {
						$(document).scrollTop($(document).scrollTop() + 3000);
					}
					i++;
				}
			</script>
			<!-- 这里是JS区域结束 -->
		</div>
	</body>
</html>
